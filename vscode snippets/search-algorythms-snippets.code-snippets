{
  // This is a collection of search algorythms for strings and arrays
  // @author: John Ericson Rodriguez <tbogard@streamoverlaypro.com>
  "Linear Search": {
    "description": "search a value against an array that could be sorted or not.",
    "scope": "javascript,typescript",
    "prefix": "linearsearch",
    "body": [
      "/*",
      "* Linear Search: search a value against an array that could be sorted or not.",
      "* Time Complexity: O(n)",
      "* Space Complexity: O(1)",
      "* @param source {Array}",
      "* @param value {Integer}",
      "* @return {Integer} returns the index of the requested element. return -1 if not found",
      "*/",
      "const $1 = (source,value) => {",
      "\tfor (let i = 0; i < source.length; i++) {",
      "\t\tif(source[i] === value) return i",
      "\t}",
      "\treturn -1",
      "}",
      "console.log($1([1,2,3,4,5,6,8],6))",
      "$2"
    ]
  },
  "Binary Search": {
    "description": "Binary Search: An Improved search method that is faster than linear search in ONLY SORTED ARRAY.",
    "scope": "javascript,typescript",
    "prefix": "binarysearch",
    "body": [
      "/*",
      "* Binary Search: An Improved search method that is faster than linear search in ONLY SORTED ARRAYS.",
      "* Time Complexity: it is variable, Best is O(1). Worst is O(log n)",
      "* Space Complexity: O(1) (linear)",
      "* @param source {Array}",
      "* @param value {Integer}",
      "* @return {Integer} returns the index of the requested element. return -1 if not found",
      "*/",
      "const $1 = (arr,valueToFind) => {",
      "\tlet left = 0",
      "\tlet right = arr.length - 1",
      "\tlet middle = Math.floor(right / 2)",
      "\twhile (arr[middle] !== valueToFind && left <= right) {",
      "\t\tif(valueToFind < arr[middle]) right = middle - 1",
      "\t\telse left = middle + 1",
      "\t\tmiddle = Math.floor((left + right) / 2)",
      "\t\t",
      "\t}",
      "\treturn arr[middle] === valueToFind ? middle : -1",
      "}",
      "console.log($1([1,2,3,4,5,6,8],6))",
      "$2"
    ]
  },
  "Naive String Search": {
    "description": "Naive String search: it is a function to find how many matches value has on a source string.",
    "prefix": "naivestring",
    "scope": "javascript,typescript",
    "body": [
      "/*",
      "* Naive String search (Or linear string search): it is a function to find how many matches value has on source string.",     
      "* Time Complexity: O(n pow 2) (exponential)",
      "* Space Complexity: O(n pow 2) (exponential)",
      "* @param source {Array}",
      "* @param value {Integer}",
      "* @return {Integer}",
      "*/",
      "const $1 = (source,value) => {",
      "\tlet countFound = 0",
      "\tfor(let idxSource = 0; idxSource < source.length - 1; idxSource++){",
      "\t\tfor(let idxValue = 0; idxValue < value.length - 1; idxValue++) {",
      "\t\t\tif( value[idxValue] !== source[idxSource + idxValue]) break",
      "\t\t\tif (idxValue === value.length - 1) countFound++",
      "\t\t}",
      "\t}",
      "\treturn countFound",
      "}",
      "console.log($1(\"onionboniosonion\",\"onion\"))",
      "$2"
    ]
  },
  "KMP String Search": {
    "description": "KMP String search: it is an optimized algorythm to find matched values in a source text",
    "prefix": "kmpsearch",
    "scope": "javascript,typescript",
    "body": [
      "/*",
      "* KMP String search: it is an optimized algorythm to find matched values in a source text",
      "* Time Complexity: O(n+m) (linear)",
      "* Space Complexity: O(n) (scalar)",
      "* @param text {String}",
      "* @param word {String}",
      "* @return {Object}",
      "*/",
      "const KMPStringSearch = (text, word) => {",
      "\tconst KMPSearch = (text, word) => { // Time O(n)",
      "\t\tif (word.length === 0) return 0",
      "\t\tlet textIndex = 0",
      "\t\tlet wordIndex = 0",
      "\t\tlet indexes = []",
      "\t\tlet ocurrences = 0",
      "\t\tconst patternTable = buildPatternTable(word)",
      "\t\twhile (textIndex < text.length) {",
      "\t\t\tif (text[textIndex] === word[wordIndex]) {",
      "\t\t\t\t// word found on text...",
      "\t\t\t\tif (wordIndex === word.length - 1) {",
      "\t\t\t\t\tindexes.push((textIndex - word.length) + 1)",
      "\t\t\t\t\tocurrences += 1",
      "\t\t\t\t}",
      "\t\t\t\twordIndex += 1",
      "\t\t\t\ttextIndex += 1",
      "\t\t\t} else if (wordIndex > 0) {",
      "\t\t\t\twordIndex = patternTable[wordIndex - 1]",
      "\t\t\t} else {",
      "\t\t\t\twordIndex = 0",
      "\t\t\t\ttextIndex += 1",
      "\t\t\t}",
      "\t\t}",
      "\t\tif(indexes.length === 0) indexes = -1",
      "\t\treturn {ocurrences,indexes}",
      "\t}",
      "\tconst buildPatternTable = (word) => {",
      "\t\tconst patternTable = [0]",
      "\t\tlet prefixIndex = 0",
      "\t\tlet suffixIndex = 1",
      "\t\twhile (suffixIndex < word.length) {",
      "\t\t\tif (word[prefixIndex] === word[suffixIndex]) {",
      "\t\t\t\tpatternTable[suffixIndex] = prefixIndex + 1",
      "\t\t\t\tsuffixIndex += 1",
      "\t\t\t\tprefixIndex += 1",
      "\t\t\t} else if (prefixIndex === 0) {",
      "\t\t\t\tpatternTable[suffixIndex] = 0",
      "\t\t\t\tsuffixIndex += 1",
      "\t\t\t} else {",
      "\t\t\t\tprefixIndex = patternTable[prefixIndex - 1]",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn patternTable",
      "\t}",
      "\treturn KMPSearch(text, word)",
      "}",
      "console.log(KMPStringSearch(\"onionboniosonion\", \"on\"))",
      "$2"
    ]
  }
}
