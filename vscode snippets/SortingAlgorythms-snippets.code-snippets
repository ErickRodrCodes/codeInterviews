{
  // This is a collection of sort algorythms for strings and arrays.
  // You can see how different algorythms sorting works by 
  // vising https://www.toptal.com/developers/sorting-algorithms
  // Note that Bubble,Insertion and Selection sorts works very well in
  // very small datasets.
  // and decide what snippet to use based on the layout of your data.
  // @author: John Ericson Rodriguez <tbogard@streamoverlaypro.com>
  "Benchmark Sort": {
    "description": "This snippet let you benchmark your sorting algorythm against a short dataset and a long dataset",
    "scope": "javascript,typescript",
    "prefix": "benchmarksort",
    "body": [
      "/*",
      "* You can benchmark your search algorythm against two sets of data.",
      "*/",
      "let data_$1 = Array.apply(null,{length:1000}).map(Function.call,Math.random)",
      "console.time('$1 - Small Dataset - 1.000 items')",
      "$1(data_$1)",
      "console.timeEnd('$1 - Small Dataset - 1.000 items')",
      "data_$1 = Array.apply(null,{length:100000}).map(Function.call,Math.random)",
      "console.time('$1 - Large Dataset - 100.000 items')",
      "$1(data_$1)",
      "console.timeEnd('$1 - Large Dataset - 100.000 items')"
    ]
  },
  "Bubble Sort ": {
    "description": "Sorts an array of numeric values using the bubble method",
    "scope": "javascript,typescript",
    "prefix": "bubblesort",
    "body": [
      "/*",
      "* Bubble Sort: Sorts an array of numeric values using the bubble method",
      "* Time Complexity: Best: O(n), Avg:O(n^2) Worst: O(n^2)",
      "* Space Complexity: O(1)",
      "* @param arr {Array}",
      "* @return {Array} returns sorted array.",
      "*/",
      "const bubbleSort = (arr) => {",
      "\tif(arr.length === 1) return arr",
      "\tconst swap = (arr, idx1, idx2) => [arr[idx1],arr[idx2]] = [arr[idx2],arr[idx1]]",
      "\tlet noswaps;",
      "\tfor (let i = arr.length; i > 0; i-=1){",
      "\t\tnoswaps = true;",
      "\t\tfor(let j = 0; j < i - 1; j++){",
      "\t\t\tif(arr[j] > arr[j+1]){",
      "\t\t\t\tswap(arr,j,j+1)",
      "\t\t\t\tnoswaps = false",
      "\t\t\t}",
      "\t\t}",
      "\t\tif(noswaps) break;",
      "\t}",
      "\treturn arr",
      "}",
      "$2"
    ]
  },
  "Selection Sort": {
    "description": "Sorts an array of numeric values using the selection method",
    "scope": "javascript,typescript",
    "prefix": "selectionsort",
    "body": [
      "/*",
      "* Selection Sort: Sorts an array of numeric values using the selection method",
      "* Time Complexity:  Best: O(n^2), Avg:O(n^2) Worst: O(n^2)",
      "* Space Complexity: O(1)",
      "* @param arr {Array}",
      "* @return {Array} returns sorted array.",
      "*/",
      "const selectionSort = (arr) => {",
      "\tif(arr.length === 1) return arr",
      "\tconst swap = (arr, idx1, idx2) => [arr[idx1],arr[idx2]] = [arr[idx2],arr[idx1]]",
      "\tlet minValIndex = 0;",
      "\tfor (let i = 0; i < arr.length; i++){",
      "\t\tminValIndex = i",
      "\t\tfor(let j = i + 1; j < arr.length; j++){",
      "\t\t\tif(arr[j] < arr[minValIndex]) minValIndex = j",
      "\t\t}",
      "\t\tif(i !== minValIndex) swap(arr,i,minValIndex)",
      "\t}",
      "\treturn arr",
      "}",
      "$2"
    ]
  },
  "Insertion Sort": {
    "description": "Sorts an array of numeric values using the insertion method",
    "scope": "javascript,typescript",
    "prefix": "insertionsort",
    "body": [
      "/*",
      "* Insertion Sort: Sorts an array of numeric values using the insertion method",
      "* Time Complexity:  Best: O(n), Avg:O(n^2) Worst: O(n^2)",
      "* Space Complexity: O(1)",
      "* @param arr {Array}",
      "* @return {Array} returns sorted array.",
      "*/",
      "const insertionSort = (arr) => {",
      "\tfor(let i = 1; i < arr.length; i++){",
      "\t\tlet currentValue = arr[i]",
      "\t\t//why var and not let? we need the value of j + 1 to assign current value when",
      "\t\t//we find the correct element given the for below.",
      "\t\t//j must be available out of the for scope after for finishes looping.",
      "\t\tfor(var j = i -1; j >= 0 && arr[j] > currentValue; j--){",
      "\t\t\tarr[j + 1] = arr[j]",
      "\t\t}",
      "\t\tarr[j+1] = currentValue",
      "\t}",
      "\treturn arr",
      "}",
      "$2"
    ]
  },
  "Merge Sort": {
    "description": "Sorts an array of numeric values using the Merge method",
    "scope": "javascript,typescript",
    "prefix": "mergesort",
    "body": [
      "/*",
      "* Merge Sort: Sorts an array of numeric values using the merge method",
      "* Time Complexity:  Best: O(n log n), Avg:O(n log n) Worst: O(n log n)",
      "* Space Complexity: O(n)",
      "* @param arr {Array}",
      "* @return {Array} returns sorted array.",
      "*/",
      "const mergeSort = (arr) => {",
      "\t// mergeArrays fn uses time and space is O(n+m) since we are providing ",
      "\t// two inputs to process without modifying them",
      "\tconst mergeArrays = (arr1,arr2) => { ",
      "\t\tconst mergedArray = []",
      "\t\tlet i=0",
      "\t\tlet j=0",
      "\t\twhile(i < arr1.length && j < arr2.length){",
      "\t\t\tif(arr2[j] > arr1[i]){",
      "\t\t\t\tmergedArray.push(arr1[i])",
      "\t\t\t\ti++   ",
      "\t\t\t} else {",
      "\t\t\t\tmergedArray.push(arr2[j])",
      "\t\t\t\tj++",
      "\t\t\t}",
      "\t\t}",
      "\t\twhile( i < arr1.length){",
      "\t\t\tmergedArray.push(arr1[i])",
      "\t\t\ti++",
      "\t\t}",
      "\t\twhile( j < arr2.length){",
      "\t\t\tmergedArray.push(arr2[j])",
      "\t\t\tj++",
      "\t\t}",
      "\t\treturn mergedArray",
      "\t}",
      "\tconst divideAndConquer = (arr) => {",
      "\t\tif (arr.length <= 1) return arr",
      "\t\tconst half = Math.floor(arr.length / 2)",
      "\t\tconst left = divideAndConquer(arr.slice(0,half))",
      "\t\tconst right = divideAndConquer(arr.slice(half))",
      "\t\treturn mergeArrays(left,right)",
      "\t}",
      "\treturn divideAndConquer(arr)",
      "}",
      "$2"
    ]
  },
  "Quick Sort": {
    "description": "Sorts an array of numeric values using the Quick method",
    "scope": "javascript,typescript",
    "prefix": "quicksort",
    "body": [
      "/*",
      "* Quick Sort: Sorts an array of numeric values using the Quick method",
      "* Time Complexity:  Best: O(n log n), Avg:O(n log n) Worst: O(n^2)",
      "* However, you can improve the time complexity depending on your",
      "* dataset by using the second argument: you provide here the index you",
      "* want to use to segment the sorting. For example:",
      "* - Provide 0 if you want to use he first index of the array",
      "* - Provide arr.length - 1 to use the last index of the array",
      "* - Provide Math.floor(arr.length / 2) to take the index of the item located at the middle of the array",
      "* - Provide an index with value of a randon number between 0 and the length of the array",
      "*   like Math.floor(Math.random() * arr.length - 1)",
      "* - or provide an arbitrary value of your choice",
      "* - If no value is provided, the value of the starting index is 0",
      "* - This method could present problems in large datasets due to the",
      "*   recursive calls it does to swap items (Max call stack size error)",
      "* Space Complexity: O(log n)",
      "* @param arr   {Array}   array to sort",
      "* @param start {Integer} position of the index where you want to start segmenting the sort",
      "* @return {Array} returns sorted array.",
      "*/",
      "const quickSort = (arr, start = 0) => {",
      "\tlet startPoint = start;",
      "\tif(start > arr.length - 1 ",
      "\t\t|| typeof start !== 'number'",
      "\t\t|| start < 0) startPoint = 0",
      "\tconst swap = (arr, a, b) => [arr[a], arr[b]] = [arr[b], arr[a]]",
      "\tconst pivot = (arr, start = startPoint, end = arr.length - 1) => {",
      "\t\tlet pivot = arr[start]",
      "\t\tlet swapIdx = start;",
      "\t\tfor (let index = start + 1; index < end; index++) {",
      "\t\t\tif (pivot > arr[index]) {",
      "\t\t\t\tswapIdx += 1;",
      "\t\t\t\tswap(arr, swapIdx, index)",
      "\t\t\t}",
      "\t\t}",
      "\t\tswap(arr, start, swapIdx)",
      "\t\treturn swapIdx",
      "\t}",
      "\tconst sort = (arr, left = 0, right = arr.length - 1) => {",
      "\t\tif (left < right) {",
      "\t\t\tlet pivotIndex = pivot(arr, left, right);",
      "\t\t\tsort(arr, left, pivotIndex - 1)",
      "\t\t\tsort(arr, pivotIndex + 1, right)",
      "\t\t}",
      "\t\treturn arr;",
      "\t}",
      "\treturn sort(arr)",
      "}",
      "$2"
    ]
  },
  "Radix Sort": {
    "description": "Sorts an array of numeric values using the Radix method",
    "scope": "javascript,typescript",
    "prefix": "radixsort",
    "body": [
      "/*",
      "* Radix Sort: Sorts an array of numeric values using the Radix method",
      "* Time Complexity:  Best: O(nk), Avg:O(nk) Worst: O(nk)",
      "* Space Complexity: O(n+k)",
      "* @param arr {Array}",
      "* @return {Array} returns sorted array.",
      "*/",
      "var radixSort = (arr) => {",
      "\t/*",
      "\t* get the number given the place on the number",
      "\t* radixSort(14578,2) = 5",
      "\t* radixSort(14578,0) = 8",
      "\t* radixSort(14578,4) = 1",
      "\t* radixSort(14578,5) = 0",
      "\t*/",
      "\tconst getDigit = (num, place) => Math.floor(Math.abs(num) / Math.pow(10, place)) % 10",
      "",
      "\t/*",
      "\t* get the length of a number",
      "\t* 1 = 1",
      "\t* 23 = 2",
      "\t* 4562 = 4",
      "\t*/",
      "\tconst getDigitMaxLength = (num) => num === 0 ? 0 : Math.floor(Math.log10(Math.abs(num))) + 1",
      "",
      "\t/*",
      "\t* Returns the length of the digit with most length (not value) from an array",
      "\t*/",
      "\tconst getMostLengthDigits = (arr) => {",
      "\t\tlet MaxDigits = 0;",
      "\t\tarr.forEach(o => MaxDigits = Math.max(MaxDigits, getDigitMaxLength(o)))",
      "\t\treturn MaxDigits",
      "\t}",
      "",
      "\t/*",
      "\t* Uses a radix method to sort the numbers based on current length of the maximum",
      "\t* number of charactes of a number and its respective value sorted in buckets.",
      "\t*/",
      "\tconst radix = (arr) => {",
      "\t\tlet mostDigits = getMostLengthDigits(arr)",
      "\t\tfor (let k = 0; k < mostDigits; k++) {",
      "\t\t\tlet buckets = Array.from({ length: 10 }, () => [])",
      "\t\t\tfor (let idx = 0; idx < arr.length; idx++) {",
      "\t\t\t\tlet digit = getDigit(arr[idx], k)",
      "\t\t\t\tbuckets[digit].push(arr[idx])",
      "\t\t\t}",
      "\t\t\tarr = [].concat(...buckets)",
      "\t\t}",
      "\t\treturn arr",
      "\t}",
      "",
      "\treturn radix(arr)",
      "}",
      "$2"
    ]
  }
}
