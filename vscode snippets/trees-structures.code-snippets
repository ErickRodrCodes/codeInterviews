{
  // This is a collection of algorithms for data tree structures
  // @author: John Ericson Rodriguez <tbogard@streamoverlaypro.com>
  "Binary Search tree": {
    "description": " Binary Tree is a data structure where elements have at most 2 children.",
    "scope": "javascript,typescript",
    "prefix": "binarysearchtree",
    "body": [
      "/* Binary Tree is a data structure where elements have at most 2 children.",
      "* Since each element in a binary tree can have only 2 children, we ",
      "* typically name them the left and right child.",
      "* Insertion : O(log n)",
      "* Search    : O(log n)",
      "* Note: O(log n) is at its best possible if the tree has the correct structure,",
      "* however it could be possible that malformed affects its performance.",
      "*/",
      "",
      "class Node {",
      "\tconstructor(val) {",
      "\t\tthis.value = val",
      "\t\tthis.left = null //lower values than the parent goes here",
      "\t\tthis.right = null // higher values than the parent goes here",
      "\t}",
      "}",
      "",
      "class BinarySearchTree {",
      "\tconstructor() {",
      "\t\tthis.root = null",
      "\t\tthis.count = 1",
      "\t}",
      "",
      "\tinsert(val) {",
      "\t\tvar newNode = new Node(val)",
      "\t\tif (!this.root) {",
      "\t\t\tthis.root = newNode",
      "\t\t\treturn this",
      "\t\t}",
      "\t\tvar current = this.root",
      "\t\twhile (true) {",
      "\t\t\tif (val === current.value) return undefined",
      "\t\t\tif (val < current.value) {",
      "\t\t\t\tif (current.left === null) {",
      "\t\t\t\t\tcurrent.left = newNode",
      "\t\t\t\t\treturn this",
      "\t\t\t\t}",
      "\t\t\t\tcurrent = current.left",
      "\t\t\t} else {",
      "\t\t\t\tif (current.right === null) {",
      "\t\t\t\t\tcurrent.right = newNode",
      "\t\t\t\t\treturn this",
      "\t\t\t\t}",
      "\t\t\t\tcurrent = current.right",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\tsearch(val) {",
      "\t\tif (!this.root) return false",
      "\t\tvar current = this.root",
      "\t\twhile (true) {",
      "\t\t\tif (val === current.value) return true",
      "\t\t\tif (val < current.value) {",
      "\t\t\t\tif (!current.left) {",
      "\t\t\t\t\treturn false",
      "\t\t\t\t}",
      "\t\t\t\tcurrent = current.left",
      "\t\t\t} else {",
      "\t\t\t\tif (!current.right) {",
      "\t\t\t\t\treturn false",
      "\t\t\t\t}",
      "\t\t\t\tcurrent = current.right",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\tcontains(val) {",
      "\t\tif (!this.root) return false",
      "\t\tvar current = this.root",
      "\t\twhile (true) {",
      "\t\t\tif (val === current.value) return current",
      "\t\t\tif (val < current.value) {",
      "\t\t\t\tif (!current.left) {",
      "\t\t\t\t\treturn false",
      "\t\t\t\t}",
      "\t\t\t\tcurrent = current.left",
      "\t\t\t} else {",
      "\t\t\t\tif (!current.right) {",
      "\t\t\t\t\treturn false",
      "\t\t\t\t}",
      "\t\t\t\tcurrent = current.right",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\tmin() {",
      "\t\tif (!this.root) return false",
      "\t\tvar current = this.root",
      "\t\twhile (true) {",
      "\t\t\tif (!current.left) {",
      "\t\t\t\treturn current.value",
      "\t\t\t}",
      "\t\t\tcurrent = current.left",
      "\t\t}",
      "\t}",
      "",
      "\tmax() {",
      "\t\tif (!this.root) return false",
      "\t\tvar current = this.root",
      "\t\twhile (true) {",
      "\t\t\tif (!current.right) {",
      "\t\t\t\treturn current.value",
      "\t\t\t}",
      "\t\t\tcurrent = current.right",
      "\t\t}",
      "\t}",
      "}",
      "",
      "var $1 = new BinarySearchTree()",
      "$1.insert(15)",
      "$1.insert(25)",
      "$1.insert(10)",
      "$1.insert(7)",
      "$1.insert(22)",
      "$1.insert(17)",
      "$1.insert(13)",
      "$1.insert(5)",
      "$1.insert(9)",
      "$1.insert(27)",
      "$1.insert(26)"
    ]
  },
  "Tree Traversal": {
    "description": "Tree Traversal is a series of tools that allows you to traverse a tree in different ways. It receives a tree as parameter",
    "scope": "javascript,typescript",
    "prefix": "treetraversal",
    "body": [
      "/* This Traversing Tree Class provides methods to traverse a binary tree",
      "* and printing such a tree in the console.",
      "* It receives as parameter a tree on the constructor.",
      "*/",
      "class TraversingTree {",
      "\tconstructor(tree) {",
      "\t\tthis.root = tree.root || null",
      "\t\tthis.count = 1 // used for printing the tree",
      "\t}",
      "\t// Breadth First Search",
      "\tBFS() { ",
      "\t\tvar queue = []",
      "\t\tvar data = []",
      "\t\tvar node = this.root",
      "\t\tqueue.push(node)",
      "\t\twhile (queue.length) {",
      "\t\t\tnode = queue.shift()",
      "\t\t\tdata.push(node.value)",
      "\t\t\tif (node.left) queue.push(node.left)",
      "\t\t\tif (node.right) queue.push(node.right)",
      "\t\t}",
      "\t\treturn data",
      "\t}",
      "",
      "\t// Depth First Search methods",
      "\tDPSPreOrder() {",
      "\t\tvar data = []",
      "\t\tfunction traverse(node) {",
      "\t\t\tif (node) {",
      "\t\t\t\tdata.push(node.value) // we push the value first!",
      "\t\t\t\ttraverse(node.left)",
      "\t\t\t\ttraverse(node.right)",
      "\t\t\t}",
      "\t\t}",
      "\t\ttraverse(this.root)",
      "\t\treturn data",
      "\t}",
      "",
      "\tDPSPostOrder() {",
      "\t\tvar data = []",
      "\t\tfunction traverse(node) {",
      "\t\t\tif (node) {",
      "\t\t\t\ttraverse(node.left)",
      "\t\t\t\ttraverse(node.right)",
      "\t\t\t\tdata.push(node.value) // we push the value last!",
      "\t\t\t}",
      "\t\t}",
      "\t\ttraverse(this.root)",
      "\t\treturn data",
      "\t}",
      "",
      "\tDPSInOrder() {",
      "\t\tvar data = []",
      "\t\tfunction traverse(node) {",
      "\t\t\tif (node) {",
      "\t\t\t\ttraverse(node.left)",
      "\t\t\t\tdata.push(node.value) // we push the value in the middle!",
      "\t\t\t\ttraverse(node.right)",
      "\t\t\t}",
      "\t\t}",
      "\t\ttraverse(this.root)",
      "\t\treturn data",
      "\t}",
      "",
      "\t// prints a tree in the browser's console",
      "\tprint() {",
      "\t\tconsole.clear()",
      "\t\tif (!this.root) console.log('')",
      "\t\tvar count = this.count",
      "\t\tfunction printUtil(root, space = 0) {",
      "\t\t\tif (root == null) return",
      "\t\t\tspace += count",
      "\t\t\tprintUtil(root.right, space)",
      "\t\t\tvar str = ''",
      "\t\t\tfor (var i = count i < space i++) {",
      "\t\t\t\tstr += '\t'",
      "\t\t\t}",
      "\t\t\tstr += root.value",
      "\t\t\tlet chain = ''",
      "\t\t\tif (root.left !== null && root.right !== null) chain = ' <'",
      "\t\t\tif (root.left !== null && root.right === null) chain = '  \\\\\\'",
      "\t\t\tif (root.left === null && root.right !== null) chain = '  /'",
      "\t\t\tspace === count ? console.log(`%c${str + chain}`, 'font-weight:bold color:red') : console.log(str + chain)",
      "\t\t\tprintUtil(root.left, space)",
      "\t\t}",
      "\t\tprintUtil(this.root, 0)",
      "\t}",
      "}",
      "var TT = new TraversingTree($1)"
    ]
  },
  "Binary Heap Tree": {
    "description": "Binary Heap Tree are similar to binary search trees, with a couple differences related on MaxBinaryHeap and MinBinaryHeap.",
    "scope": "javascript,typescript",
    "prefix": "binaryheap",
    "body": [
      "/*",
      "* Binary Heap Tree are similar to binary search trees. BHT are very",
      "* useful for sorting and implementing other data structures such Priority Queues.",
      "* commonly BHT has two approaches: MaxBinaryHeap where the biggest number on the tree ",
      "* is on the root and MinBinaryHeap is where the minimum value is located at the root.",
      "* In this snippet we use a MaxBinaryHeap Class.",
      "* Insertion : O(log N), Worst: O(N)",
      "* Deletion  : O(log N), Worst: O(N)",
      "* Searching : O(N)",
      "*/",
      "",
      "class MaxBinaryHeap {",
      "\tconstructor() {",
      "\t\tthis.values = []",
      "\t\tthis.printIdx = 0",
      "\t}",
      "",
      "\tgetParentIdx(idx) {",
      "\t\treturn Math.floor((idx - 1) / 2)",
      "\t}",
      "",
      "\tgetChildrenIdx(idx) {",
      "\t\tlet idxLeft = 2 * idx + 1",
      "\t\tlet idxRight = 2 * idx + 2",
      "\t\tlet length = this.values.length",
      "\t\treturn {",
      "\t\t\tleftChildIdx: idxLeft < length ? idxLeft : null,",
      "\t\t\trightChildIdx: idxRight < length ? idxRight : null",
      "\t\t}",
      "\t}",
      "",
      "\tinsert(element) {",
      "\t\tthis.values.push(element)",
      "\t\tthis.bubbleUp()",
      "\t}",
      "\tbubbleUp() {",
      "\t\tlet idx = this.values.length - 1",
      "\t\tconst element = this.values[idx]",
      "\t\twhile (idx > 0) {",
      "\t\t\tlet parentIdx = this.getParentIdx(idx)",
      "\t\t\tlet parent = this.values[parentIdx]",
      "\t\t\tif (element <= parent)",
      "\t\t\t\tbreak",
      "\t\t\tthis.values[parentIdx] = element",
      "\t\t\tthis.values[idx] = parent",
      "\t\t\tidx = parentIdx",
      "\t\t}",
      "\t}",
      "",
      "\tsinkDown() {",
      "\t\tlet idx = 0",
      "\t\t//starts at the top",
      "\t\tconst element = this.values[0]",
      "\t\tlet leftChild",
      "\t\tlet rightChild",
      "\t\twhile (true) {",
      "\t\t\tlet {leftChildIdx, rightChildIdx} = this.getChildrenIdx(idx)",
      "\t\t\tlet swap = null",
      "\t\t\tif (leftChildIdx) {",
      "\t\t\t\tleftChild = this.values[leftChildIdx]",
      "\t\t\t\tif (leftChild > element)",
      "\t\t\t\t\tswap = leftChildIdx",
      "\t\t\t}",
      "\t\t\tif (rightChildIdx) {",
      "\t\t\t\trightChild = this.values[rightChildIdx]",
      "\t\t\t\tif ((swap === null && rightChild > element) || (swap !== null && rightChild > leftChild))",
      "\t\t\t\t\tswap = rightChildIdx",
      "\t\t\t}",
      "\t\t\tif (swap === null)",
      "\t\t\t\tbreak",
      "\t\t\tthis.values[idx] = this.values[swap]",
      "\t\t\tthis.values[swap] = element",
      "\t\t\tidx = swap",
      "\t\t}",
      "\t}",
      "",
      "\textractMax() {",
      "\t\tif (!this.values.length)",
      "\t\t\treturn undefined",
      "\t\tconst max = this.values[0]",
      "\t\tconst end = this.values.pop()",
      "\t\tif (this.values.length > 0) {",
      "\t\t\tthis.values[0] = end",
      "\t\t\tthis.sinkDown()",
      "\t\t}",
      "\t\treturn max",
      "\t}",
      "}",
      "",
      "var $1 = new MaxBinaryHeap()",
      "[41, 39, 33, 18, 27, 12, 55].forEach(i => $1.insert(i))",
      "console.log($1)"
    ]
  },
  "Priority Queue": {
    "description": "Priority Queues is an implementation of a Binary Heap Tree by using MaxBinaryHeap or MinBinaryHeap to allow nodes to be processed accordingly to the priority value they have.",
    "scope": "javascript,typescript",
    "prefix": "priorityQueue",
    "body": [
      "/*",
      "* Priority Queues is an implementation of a Binary Heap Tree by using ",
      "* MaxBinaryHeap or MinBinaryHeap to allow nodes to be processed ",
      "* accordingly to the priority value they have.",
      "* Insertion : O(log N), Worst: O(N)",
      "* Deletion  : O(log N), Worst: O(N)",
      "* Searching : O(N)",
      "*/",
      "",
      "class PQNode {",
      "\tconstructor(value, priority) {",
      "\t\tthis.value = value",
      "\t\tthis.priority = priority",
      "\t}",
      "}",
      "",
      "class PriorityQueue {",
      "\tconstructor() {",
      "\t\tthis.values = []",
      "\t}",
      "",
      "\tgetParentIdx(idx) {",
      "\t\treturn Math.floor((idx - 1) / 2)",
      "\t}",
      "",
      "\tgetChildrenIdx(idx) {",
      "\t\tlet idxLeft = 2 * idx + 1",
      "\t\tlet idxRight = 2 * idx + 2",
      "\t\tlet length = this.values.length",
      "\t\treturn {",
      "\t\t\tleftChildIdx: idxLeft < length ? idxLeft : null,",
      "\t\t\trightChildIdx: idxRight < length ? idxRight : null",
      "\t\t}",
      "\t}",
      "",
      "\tenqueue(value, priority) {",
      "\t\tlet newNode = new PQNode(value, priority)",
      "\t\tthis.values.push(newNode);",
      "\t\tthis.bubbleUp();",
      "\t}",
      "",
      "\tbubbleUp() {",
      "\t\tlet idx = this.values.length - 1;",
      "\t\tconst element = this.values[idx];",
      "\t\twhile (idx > 0) {",
      "\t\t\tlet parentIdx = this.getParentIdx(idx);",
      "\t\t\tlet parent = this.values[parentIdx];",
      "\t\t\tif (element.priority <= parent.priority)",
      "\t\t\t\t// use this for MaxBinaryHeap",
      "\t\t\t\t// if (element.priority >= parent.priority) // use this for MinBinaryHeap",
      "\t\t\t\tbreak;",
      "\t\t\tthis.values[parentIdx] = element;",
      "\t\t\tthis.values[idx] = parent;",
      "\t\t\tidx = parentIdx;",
      "\t\t}",
      "\t}",
      "",
      "\tsinkDown() {",
      "\t\tlet idx = 0",
      "\t\t//starts at the top",
      "\t\tconst element = this.values[0]",
      "\t\tlet leftChild;",
      "\t\tlet rightChild;",
      "\t\twhile (true) {",
      "\t\t\tlet { leftChildIdx, rightChildIdx } = this.getChildrenIdx(idx);",
      "\t\t\tlet swap = null;",
      "\t\t\tif (leftChildIdx) {",
      "\t\t\t\tleftChild = this.values[leftChildIdx]",
      "\t\t\t\t//if (leftChild.priority > element.priority) // use this for MaxBinaryHeap",
      "\t\t\t\tif (leftChild.priority < element.priority)",
      "\t\t\t\t\t// use this for MinBinaryHeap",
      "\t\t\t\t\tswap = leftChildIdx",
      "\t\t\t}",
      "\t\t\tif (rightChildIdx) {",
      "\t\t\t\trightChild = this.values[rightChildIdx]",
      "\t\t\t\tif ((swap === null && rightChild.priority > element.priority) || (swap !== null && rightChild.priority > leftChild.priority))",
      "\t\t\t\t\t// use this for MaxBinaryHeap",
      "\t\t\t\t\t// if ((swap === null && rightChild.priority < element.priority) || (swap !== null && rightChild.priority < leftChild.priority)) // use this for MinBinaryHeap",
      "\t\t\t\t\tswap = rightChildIdx",
      "\t\t\t}",
      "\t\t\tif (swap === null)",
      "\t\t\t\tbreak;",
      "\t\t\tthis.values[idx] = this.values[swap]",
      "\t\t\tthis.values[swap] = element",
      "\t\t\tidx = swap",
      "\t\t}",
      "\t}",
      "",
      "\tdequeue() {",
      "\t\tif (!this.values.length)",
      "\t\t\treturn undefined;",
      "\t\tconst root = this.values[0]",
      "\t\tconst end = this.values.pop()",
      "\t\tif (this.values.length > 0) {",
      "\t\t\tthis.values[0] = end;",
      "\t\t\tthis.sinkDown()",
      "\t\t}",
      "\t\treturn root;",
      "\t}",
      "}",
      "",
      "let ER = new PriorityQueue()",
      "",
      "ER.enqueue(\"common cold\", 5)",
      "ER.enqueue(\"gunshot\", 1)",
      "ER.enqueue(\"high fever\", 4)",
      "ER.enqueue(\"broken arm\", 2)",
      "ER.enqueue(\"deep cut wound\", 3)",
      "ER.enqueue(\"high fever\", 4)"
    ]
  }
}
